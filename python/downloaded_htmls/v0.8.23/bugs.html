<!DOCTYPE html>
<html class="writer-html5" lang="en" >

<!-- Mirrored from docs.soliditylang.org/en/v0.8.23/bugs.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 02 Jan 2024 20:36:17 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>List of Known Bugs &mdash; Solidity 0.8.23 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/a4_railroad_diagram.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/fonts.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom-dark.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/toggle.css" type="text/css" />
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script async="async" src="https://docs.soliditylang.org/_/static/javascript/readthedocs-doc-embed.js"></script>
        <script src="_static/js/constants.js"></script>
        <script src="_static/js/initialize.js"></script>
        <script src="_static/js/toggle.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Solidity v0.5.0 Breaking Changes" href="050-breaking-changes.html" />
    <link rel="prev" title="Security Considerations" href="security-considerations.html" /> 

<!-- RTD Extra Head -->

<link rel="stylesheet" href="https://docs.soliditylang.org/_/static/css/readthedocs-doc-embed.css" type="text/css" />

<script type="application/json" id="READTHEDOCS_DATA">{"ad_free": true, "api_host": "https://readthedocs.org", "builder": "sphinx", "canonical_url": null, "docroot": "/docs/", "features": {"docsearch_disabled": false}, "global_analytics_code": null, "language": "en", "page": "bugs", "programming_language": "cpp", "project": "solidity", "proxied_api_host": "/_", "source_suffix": ".rst", "subprojects": {}, "theme": "sphinx_rtd_theme", "user_analytics_code": "", "version": "v0.8.23"}</script>

<!--
Using this variable directly instead of using `JSON.parse` is deprecated.
The READTHEDOCS_DATA global variable will be removed in the future.
-->
<script type="text/javascript">
READTHEDOCS_DATA = JSON.parse(document.getElementById('READTHEDOCS_DATA').innerHTML);
</script>

<script type="text/javascript" src="https://docs.soliditylang.org/_/static/javascript/readthedocs-analytics.js" async="async"></script>

<!-- end RTD <extrahead> -->
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index-2.html">
            
          </a>
              <div class="version">
                v0.8.23
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="https://docs.soliditylang.org/en/v0.8.23/search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    
              <p class="caption" role="heading"><span class="caption-text">Basics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction-to-smart-contracts.html">Introduction to Smart Contracts</a></li>
<li class="toctree-l1"><a class="reference internal" href="solidity-by-example.html">Solidity by Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="installing-solidity.html">Installing the Solidity Compiler</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Language Description</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="layout-of-source-files.html">Layout of a Solidity Source File</a></li>
<li class="toctree-l1"><a class="reference internal" href="structure-of-a-contract.html">Structure of a Contract</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html">Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="units-and-global-variables.html">Units and Globally Available Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="control-structures.html">Expressions and Control Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="contracts.html">Contracts</a></li>
<li class="toctree-l1"><a class="reference internal" href="assembly.html">Inline Assembly</a></li>
<li class="toctree-l1"><a class="reference internal" href="cheatsheet.html">Cheatsheet</a></li>
<li class="toctree-l1"><a class="reference internal" href="grammar.html">Language Grammar</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Compiler</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="using-the-compiler.html">Using the Compiler</a></li>
<li class="toctree-l1"><a class="reference internal" href="analysing-compilation-output.html">Analysing the Compiler Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="ir-breaking-changes.html">Solidity IR-based Codegen Changes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Internals</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="internals/layout_in_storage.html">Layout of State Variables in Storage</a></li>
<li class="toctree-l1"><a class="reference internal" href="internals/layout_in_memory.html">Layout in Memory</a></li>
<li class="toctree-l1"><a class="reference internal" href="internals/layout_in_calldata.html">Layout of Call Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="internals/variable_cleanup.html">Cleaning Up Variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="internals/source_mappings.html">Source Mappings</a></li>
<li class="toctree-l1"><a class="reference internal" href="internals/optimizer.html">The Optimizer</a></li>
<li class="toctree-l1"><a class="reference internal" href="metadata.html">Contract Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="abi-spec.html">Contract ABI Specification</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advisory content</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="security-considerations.html">Security Considerations</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">List of Known Bugs</a></li>
<li class="toctree-l1"><a class="reference internal" href="050-breaking-changes.html">Solidity v0.5.0 Breaking Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="060-breaking-changes.html">Solidity v0.6.0 Breaking Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="070-breaking-changes.html">Solidity v0.7.0 Breaking Changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="080-breaking-changes.html">Solidity v0.8.0 Breaking Changes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Additional Material</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="natspec-format.html">NatSpec Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="smtchecker.html">SMTChecker and Formal Verification</a></li>
<li class="toctree-l1"><a class="reference internal" href="yul.html">Yul</a></li>
<li class="toctree-l1"><a class="reference internal" href="path-resolution.html">Import Path Resolution</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Resources</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="style-guide.html">Style Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="common-patterns.html">Common Patterns</a></li>
<li class="toctree-l1"><a class="reference internal" href="resources.html">Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="language-influences.html">Language Influences</a></li>
<li class="toctree-l1"><a class="reference internal" href="brand-guide.html">Solidity Brand Guide</a></li>
</ul>

    <ul>
        <li>
            <a href="genindex.html">Keyword Index</a>
        </li>
    </ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index-2.html">Solidity</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index-2.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">List of Known Bugs</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/ethereum/solidity/blob/v0.8.23/docs/bugs.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="list-of-known-bugs">
<span id="known-bugs"></span><span id="index-0"></span><h1>List of Known Bugs<a class="headerlink" href="#list-of-known-bugs" title="Permalink to this heading"></a></h1>
<p>Below, you can find a JSON-formatted list of some of the known security-relevant bugs in the
Solidity compiler. The file itself is hosted in the <a class="reference external" href="https://github.com/ethereum/solidity/blob/develop/docs/bugs.json">Github repository</a>.
The list stretches back as far as version 0.3.0, bugs known to be present only
in versions preceding that are not listed.</p>
<p>There is another file called <a class="reference external" href="https://github.com/ethereum/solidity/blob/develop/docs/bugs_by_version.json">bugs_by_version.json</a>,
which can be used to check which bugs affect a specific version of the compiler.</p>
<p>Contract source verification tools and also other tools interacting with
contracts should consult this list according to the following criteria:</p>
<ul class="simple">
<li><p>It is mildly suspicious if a contract was compiled with a nightly
compiler version instead of a released version. This list does not keep
track of unreleased or nightly versions.</p></li>
<li><p>It is also mildly suspicious if a contract was compiled with a version that was
not the most recent at the time the contract was created. For contracts
created from other contracts, you have to follow the creation chain
back to a transaction and use the date of that transaction as creation date.</p></li>
<li><p>It is highly suspicious if a contract was compiled with a compiler that
contains a known bug and the contract was created at a time where a newer
compiler version containing a fix was already released.</p></li>
</ul>
<p>The JSON file of known bugs below is an array of objects, one for each bug,
with the following keys:</p>
<dl class="simple">
<dt>uid</dt><dd><p>Unique identifier given to the bug in the form of <code class="docutils literal notranslate"><span class="pre">SOL-&lt;year&gt;-&lt;number&gt;</span></code>.
It is possible that multiple entries exists with the same uid. This means
multiple version ranges are affected by the same bug.</p>
</dd>
<dt>name</dt><dd><p>Unique name given to the bug</p>
</dd>
<dt>summary</dt><dd><p>Short description of the bug</p>
</dd>
<dt>description</dt><dd><p>Detailed description of the bug</p>
</dd>
<dt>link</dt><dd><p>URL of a website with more detailed information, optional</p>
</dd>
<dt>introduced</dt><dd><p>The first published compiler version that contained the bug, optional</p>
</dd>
<dt>fixed</dt><dd><p>The first published compiler version that did not contain the bug anymore</p>
</dd>
<dt>publish</dt><dd><p>The date at which the bug became known publicly, optional</p>
</dd>
<dt>severity</dt><dd><p>Severity of the bug: very low, low, medium, high. Takes into account
discoverability in contract tests, likelihood of occurrence and
potential damage by exploits.</p>
</dd>
<dt>conditions</dt><dd><p>Conditions that have to be met to trigger the bug. The following
keys can be used:
<code class="docutils literal notranslate"><span class="pre">optimizer</span></code>, Boolean value which
means that the optimizer has to be switched on to enable the bug.
<code class="docutils literal notranslate"><span class="pre">evmVersion</span></code>, a string that indicates which EVM version compiler
settings trigger the bug. The string can contain comparison
operators. For example, <code class="docutils literal notranslate"><span class="pre">&quot;&gt;=constantinople&quot;</span></code> means that the bug
is present when the EVM version is set to <code class="docutils literal notranslate"><span class="pre">constantinople</span></code> or
later.
If no conditions are given, assume that the bug is present.</p>
</dd>
<dt>check</dt><dd><p>This field contains different checks that report whether the smart contract
contains the bug or not. The first type of check are JavaScript regular
expressions that are to be matched against the source code (“source-regex”)
if the bug is present.  If there is no match, then the bug is very likely
not present. If there is a match, the bug might be present.  For improved
accuracy, the checks should be applied to the source code after stripping
comments.
The second type of check are patterns to be checked on the compact AST of
the Solidity program (“ast-compact-json-path”). The specified search query
is a <a class="reference external" href="https://github.com/json-path/JsonPath">JsonPath</a> expression.
If at least one path of the Solidity AST matches the query, the bug is
likely present.</p>
</dd>
</dl>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="p">[</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2023-3&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;VerbatimInvalidDeduplication&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;All ``verbatim`` blocks are considered identical by deduplicator and can incorrectly be unified when surrounded by identical opcodes.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The block deduplicator is a step of the opcode-based optimizer which identifies equivalent assembly blocks and merges them into a single one. However, when blocks contained ``verbatim``, their comparison was performed incorrectly, leading to the collapse of assembly blocks which are identical except for the contents of the ``verbatim`` items. Since ``verbatim`` is only available in Yul, compilation of Solidity sources is not affected.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2023/11/08/verbatim-invalid-deduplication-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.23&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2023-2&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;FullInlinerNonExpressionSplitArgumentEvaluationOrder&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Optimizer sequences containing FullInliner do not preserve the evaluation order of arguments of inlined function calls in code that is not in expression-split form.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Function call arguments in Yul are evaluated right to left. This order matters when the argument expressions have side-effects, and changing it may change contract behavior. FullInliner is an optimizer step that can replace a function call with the body of that function. The transformation involves assigning argument expressions to temporary variables, which imposes an explicit evaluation order. FullInliner was written with the assumption that this order does not necessarily have to match usual argument evaluation order because the argument expressions have no side-effects. In most circumstances this assumption is true because the default optimization step sequence contains the ExpressionSplitter step. ExpressionSplitter ensures that the code is in *expression-split form*, which means that function calls cannot appear nested inside expressions, and all function call arguments have to be variables. The assumption is, however, not guaranteed to be true in general. Version 0.6.7 introduced a setting allowing users to specify an arbitrary optimization step sequence, making it possible for the FullInliner to actually encounter argument expressions with side-effects, which can result in behavior differences between optimized and unoptimized bytecode. Contracts compiled without optimization or with the default optimization sequence are not affected. To trigger the bug the user has to explicitly choose compiler settings that contain a sequence with FullInliner step not preceded by ExpressionSplitter.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2023/07/19/full-inliner-non-expression-split-argument-evaluation-order-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.6.7&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.21&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;yulOptimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2023-1&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;MissingSideEffectsOnSelectorAccess&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Accessing the ``.selector`` member on complex expressions leaves the expression unevaluated in the legacy code generation.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;When accessing the ``.selector`` member on an expression with side-effects, like an assignment, a function call or a conditional, the expression would not be evaluated in the legacy code generation. This would happen in expressions where the functions used in the expression were all known at compilation time, regardless of whether the whole expression could be evaluated at compilation time or not. Note that the code generated by the IR pipeline was unaffected and would behave as expected.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2023/07/19/missing-side-effects-on-selector-access-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.6.2&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.21&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;viaIR&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">false</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2022-7&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;StorageWriteRemovalBeforeConditionalTermination&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Calling functions that conditionally terminate the external EVM call using the assembly statements ``return(...)`` or ``stop()`` may result in incorrect removals of prior storage writes.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;A call to a Yul function that conditionally terminates the external EVM call could result in prior storage writes being incorrectly removed by the Yul optimizer. This used to happen in cases in which it would have been valid to remove the store, if the Yul function in question never actually terminated the external call, and the control flow always returned back to the caller instead. Conditional termination within the same Yul block instead of within a called function was not affected. In Solidity with optimized via-IR code generation, any storage write before a function conditionally calling ``return(...)`` or ``stop()`` in inline assembly, may have been incorrectly removed, whenever it would have been valid to remove the write without the ``return(...)`` or ``stop()``. In optimized legacy code generation, only inline assembly that did not refer to any Solidity variables and that involved conditionally-terminating user-defined assembly functions could be affected.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2022/09/08/storage-write-removal-before-conditional-termination/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.13&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.17&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;medium/high&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;yulOptimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2022-6&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;AbiReencodingHeadOverflowWithStaticArrayCleanup&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ABI-encoding a tuple with a statically-sized calldata array in the last component would corrupt 32 leading bytes of its first dynamically encoded component.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;When ABI-encoding a statically-sized calldata array, the compiler always pads the data area to a multiple of 32-bytes and ensures that the padding bytes are zeroed. In some cases, this cleanup used to be performed by always writing exactly 32 bytes, regardless of how many needed to be zeroed. This was done with the assumption that the data that would eventually occupy the area past the end of the array had not yet been written, because the encoder processes tuple components in the order they were given. While this assumption is mostly true, there is an important corner case: dynamically encoded tuple components are stored separately from the statically-sized ones in an area called the *tail* of the encoding and the tail immediately follows the *head*, which is where the statically-sized components are placed. The aforementioned cleanup, if performed for the last component of the head would cross into the tail and overwrite up to 32 bytes of the first component stored there with zeros. The only array type for which the cleanup could actually result in an overwrite were arrays with ``uint256`` or ``bytes32`` as the base element type and in this case the size of the corrupted area was always exactly 32 bytes. The problem affected tuples at any nesting level. This included also structs, which are encoded as tuples in the ABI. Note also that lists of parameters and return values of functions, events and errors are encoded as tuples.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2022/08/08/calldata-tuple-reencoding-head-overflow-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.8&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.16&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;medium&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;ABIEncoderV2&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2022-5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;DirtyBytesArrayToStorage&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Copying ``bytes`` arrays from memory or calldata to storage may result in dirty storage values.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Copying ``bytes`` arrays from memory or calldata to storage is done in chunks of 32 bytes even if the length is not a multiple of 32. Thereby, extra bytes past the end of the array may be copied from calldata or memory to storage. These dirty bytes may then become observable after a ``.push()`` without arguments to the bytes array in storage, i.e. such a push will not result in a zero value at the end of the array as expected. This bug only affects the legacy code generation pipeline, the new code generation pipeline via IR is not affected.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2022/06/15/dirty-bytes-array-to-storage-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.0.1&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.15&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2022-4&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;InlineAssemblyMemorySideEffects&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The Yul optimizer may incorrectly remove memory writes from inline assembly blocks, that do not access solidity variables.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The Yul optimizer considers all memory writes in the outermost Yul block that are never read from as unused and removes them. This is valid when that Yul block is the entire Yul program, which is always the case for the Yul code generated by the new via-IR pipeline. Inline assembly blocks are never optimized in isolation when using that pipeline. Instead they are optimized as a part of the whole Yul input. However, the legacy code generation pipeline (which is still the default) runs the Yul optimizer individually on an inline assembly block if the block does not refer to any local variables defined in the surrounding Solidity code. Consequently, memory writes in such inline assembly blocks are removed as well, if the written memory is never read from in the same assembly block, even if the written memory is accessed later, for example by a subsequent inline assembly block.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2022/06/15/inline-assembly-memory-side-effects-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.13&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.15&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;medium&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;yulOptimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2022-3&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;DataLocationChangeInInternalOverride&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;It was possible to change the data location of the parameters or return variables from ``calldata`` to ``memory`` and vice-versa while overriding internal and public functions. This caused invalid code to be generated when calling such a function internally through virtual function calls.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;When calling external functions, it is irrelevant if the data location of the parameters is ``calldata`` or ``memory``, the encoding of the data does not change. Because of that, changing the data location when overriding external functions is allowed. The compiler incorrectly also allowed a change in the data location for overriding public and internal functions. Since public functions can be called internally as well as externally, this causes invalid code to be generated when such an incorrectly overridden function is called internally through the base contract. The caller provides a memory pointer, but the called function interprets it as a calldata pointer or vice-versa.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2022/05/17/data-location-inheritance-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.6.9&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.14&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2022-2&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;NestedCalldataArrayAbiReencodingSizeValidation&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ABI-reencoding of nested dynamic calldata arrays did not always perform proper size checks against the size of calldata and could read beyond ``calldatasize()``.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Calldata validation for nested dynamic types is deferred until the first access to the nested values. Such an access may for example be a copy to memory or an index or member access to the outer type. While in most such accesses calldata validation correctly checks that the data area of the nested array is completely contained in the passed calldata (i.e. in the range [0, calldatasize()]), this check may not be performed, when ABI encoding such nested types again directly from calldata. For instance, this can happen, if a value in calldata with a nested dynamic array is passed to an external call, used in ``abi.encode`` or emitted as event. In such cases, if the data area of the nested array extends beyond ``calldatasize()``, ABI encoding it did not revert, but continued reading values from beyond ``calldatasize()`` (i.e. zero values).&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2022/05/17/calldata-reencode-size-check-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.8&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.14&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2022-1&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;AbiEncodeCallLiteralAsFixedBytesBug&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Literals used for a fixed length bytes parameter in ``abi.encodeCall`` were encoded incorrectly.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;For the encoding, the compiler only considered the types of the expressions in the second argument of ``abi.encodeCall`` itself, but not the parameter types of the function given as first argument. In almost all cases the abi encoding of the type of the expression matches the abi encoding of the parameter type of the given function. This is because the type checker ensures the expression is implicitly convertible to the respective parameter type. However this is not true for number literals used for fixed bytes types shorter than 32 bytes, nor for string literals used for any fixed bytes type. Number literals were encoded as numbers instead of being shifted to become left-aligned. String literals were encoded as dynamically sized memory strings instead of being converted to a left-aligned bytes value.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2022/03/16/encodecall-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.11&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.13&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>

<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2021-4&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;UserDefinedValueTypesBug&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;User defined value types with underlying type shorter than 32 bytes used incorrect storage layout and wasted storage&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The compiler did not correctly compute the storage layout of user defined value types based on types that are shorter than 32 bytes. It would always use a full storage slot for these types, even if the underlying type was shorter. This was wasteful and might have problems with tooling or contract upgrades.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2021/09/29/user-defined-value-types-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.8&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.9&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2021-3&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SignedImmutables&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Immutable variables of signed integer type shorter than 256 bits can lead to values with invalid higher order bits if inline assembly is used.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;When immutable variables of signed integer type shorter than 256 bits are read, their higher order bits were unconditionally set to zero. The correct operation would be to sign-extend the value, i.e. set the higher order bits to one if the sign bit is one. This sign-extension is performed by Solidity just prior to when it matters, i.e. when a value is stored in memory, when it is compared or when a division is performed. Because of that, to our knowledge, the only way to access the value in its unclean state is by reading it through inline assembly.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2021/09/29/signed-immutables-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.6.5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.9&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2021-2&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ABIDecodeTwoDimensionalArrayMemory&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;If used on memory byte arrays, result of the function ``abi.decode`` can depend on the contents of memory outside of the actual byte array that is decoded.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The ABI specification uses pointers to data areas for everything that is dynamically-sized. When decoding data from memory (instead of calldata), the ABI decoder did not properly validate some of these pointers. More specifically, it was possible to use large values for the pointers inside arrays such that computing the offset resulted in an undetected overflow. This could lead to these pointers targeting areas in memory outside of the actual area to be decoded. This way, it was possible for ``abi.decode`` to return different values for the same encoded byte array.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2021/04/21/decoding-from-memory-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.16&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.4&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;ABIEncoderV2&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2021-1&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;KeccakCaching&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The bytecode optimizer incorrectly re-used previously evaluated Keccak-256 hashes. You are unlikely to be affected if you do not compute Keccak-256 hashes in inline assembly.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Solidity&#39;s bytecode optimizer has a step that can compute Keccak-256 hashes, if the contents of the memory are known during compilation time. This step also has a mechanism to determine that two Keccak-256 hashes are equal even if the values in memory are not known during compile time. This mechanism had a bug where Keccak-256 of the same memory content, but different sizes were considered equal. More specifically, ``keccak256(mpos1, length1)`` and ``keccak256(mpos2, length2)`` in some cases were considered equal if ``length1`` and ``length2``, when rounded up to nearest multiple of 32 were the same, and when the memory contents at ``mpos1`` and ``mpos2`` can be deduced to be equal. You maybe affected if you compute multiple Keccak-256 hashes of the same content, but with different lengths inside inline assembly. You are unaffected if your code uses ``keccak256`` with a length that is not a compile-time constant or if it is always a multiple of 32.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2021/03/23/keccak-optimizer-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.8.3&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;optimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;medium&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2020-11&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;EmptyByteArrayCopy&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Copying an empty byte array (or string) from memory or calldata to storage can result in data corruption if the target array&#39;s length is increased subsequently without storing new data.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The routine that copies byte arrays from memory or calldata to storage stores unrelated data from after the source array in the storage slot if the source array is empty. If the storage array&#39;s length is subsequently increased either by using ``.push()`` or by assigning to its ``.length`` attribute (only before 0.6.0), the newly created byte array elements will not be zero-initialized, but contain the unrelated data. You are not affected if you do not assign to ``.length`` and do not use ``.push()`` on byte arrays, or only use ``.push(&lt;arg&gt;)`` or manually initialize the new elements.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2020/10/19/empty-byte-array-copy-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.7.4&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;medium&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2020-10&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;DynamicArrayCleanup&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;When assigning a dynamically-sized array with types of size at most 16 bytes in storage causing the assigned array to shrink, some parts of deleted slots were not zeroed out.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Consider a dynamically-sized array in storage whose base-type is small enough such that multiple values can be packed into a single slot, such as `uint128[]`. Let us define its length to be `l`. When this array gets assigned from another array with a smaller length, say `m`, the slots between elements `m` and `l` have to be cleaned by zeroing them out. However, this cleaning was not performed properly. Specifically, after the slot corresponding to `m`, only the first packed value was cleaned up. If this array gets resized to a length larger than `m`, the indices corresponding to the unclean parts of the slot contained the original value, instead of 0. The resizing here is performed by assigning to the array `length`, by a `push()` or via inline assembly. You are not affected if you are only using `.push(&lt;arg&gt;)` or if you assign a value (even zero) to the new elements after increasing the length of the array.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2020/10/07/solidity-dynamic-array-cleanup-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.7.3&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;medium&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2020-9&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;FreeFunctionRedefinition&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The compiler does not flag an error when two or more free functions with the same name and parameter types are defined in a source unit or when an imported free function alias shadows another free function with a different name but identical parameter types.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;In contrast to functions defined inside contracts, free functions with identical names and parameter types did not create an error. Both definition of free functions with identical name and parameter types and an imported free function with an alias that shadows another function with a different name but identical parameter types were permitted due to which a call to either the multiply defined free function or the imported free function alias within a contract led to the execution of that free function which was defined first within the source unit. Subsequently defined identical free function definitions were silently ignored and their code generation was skipped.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.7.1&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.7.2&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2020-8&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;UsingForCalldata&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Function calls to internal library functions with calldata parameters called via ``using for`` can result in invalid data being read.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Function calls to internal library functions using the ``using for`` mechanism copied all calldata parameters to memory first and passed them on like that, regardless of whether it was an internal or an external call. Due to that, the called function would receive a memory pointer that is interpreted as a calldata pointer. Since dynamically sized arrays are passed using two stack slots for calldata, but only one for memory, this can lead to stack corruption. An affected library call will consider the JUMPDEST to which it is supposed to return as part of its arguments and will instead jump out to whatever was on the stack before the call.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.6.9&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.6.10&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2020-7&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;MissingEscapingInFormatting&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;String literals containing double backslash characters passed directly to external or encoding function calls can lead to a different string being used when ABIEncoderV2 is enabled.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;When ABIEncoderV2 is enabled, string literals passed directly to encoding functions or external function calls are stored as strings in the intemediate code. Characters outside the printable range are handled correctly, but backslashes are not escaped in this procedure. This leads to double backslashes being reduced to single backslashes and consequently re-interpreted as escapes potentially resulting in a different string being encoded.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.14&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.6.8&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;ABIEncoderV2&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2020-6&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ArraySliceDynamicallyEncodedBaseType&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Accessing array slices of arrays with dynamically encoded base types (e.g. multi-dimensional arrays) can result in invalid data being read.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;For arrays with dynamically sized base types, index range accesses that use a start expression that is non-zero will result in invalid array slices. Any index access to such array slices will result in data being read from incorrect calldata offsets. Array slices are only supported for dynamic calldata types and all problematic type require ABIEncoderV2 to be enabled.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.6.0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.6.8&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;ABIEncoderV2&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2020-5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ImplicitConstructorCallvalueCheck&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The creation code of a contract that does not define a constructor but has a base that does define a constructor did not revert for calls with non-zero value.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Starting from Solidity 0.4.5 the creation code of contracts without explicit payable constructor is supposed to contain a callvalue check that results in contract creation reverting, if non-zero value is passed. However, this check was missing in case no explicit constructor was defined in a contract at all, but the contract has a base that does define a constructor. In these cases it is possible to send value in a contract creation transaction or using inline assembly without revert, even though the creation code is supposed to be non-payable.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.6.8&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2020-4&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;TupleAssignmentMultiStackSlotComponents&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Tuple assignments with components that occupy several stack slots, i.e. nested tuples, pointers to external functions or references to dynamically sized calldata arrays, can result in invalid values.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Tuple assignments did not correctly account for tuple components that occupy multiple stack slots in case the number of stack slots differs between left-hand-side and right-hand-side. This can either happen in the presence of nested tuples or if the right-hand-side contains external function pointers or references to dynamic calldata arrays, while the left-hand-side contains an omission.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.1.6&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.6.6&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2020-3&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;MemoryArrayCreationOverflow&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The creation of very large memory arrays can result in overlapping memory regions and thus memory corruption.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;No runtime overflow checks were performed for the length of memory arrays during creation. In cases for which the memory size of an array in bytes, i.e. the array length times 32, is larger than 2^256-1, the memory allocation will overflow, potentially resulting in overlapping memory areas. The length of the array is still stored correctly, so copying or iterating over such an array will result in out-of-gas.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2020/04/06/memory-creation-overflow-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.2.0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.6.5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2020-1&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;YulOptimizerRedundantAssignmentBreakContinue&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The Yul optimizer can remove essential assignments to variables declared inside for loops when Yul&#39;s continue or break statement is used. You are unlikely to be affected if you do not use inline assembly with for loops and continue and break statements.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The Yul optimizer has a stage that removes assignments to variables that are overwritten again or are not used in all following control-flow branches. This logic incorrectly removes such assignments to variables declared inside a for loop if they can be removed in a control-flow branch that ends with ``break`` or ``continue`` even though they cannot be removed in other control-flow branches. Variables declared outside of the respective for loop are not affected.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.6.0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.6.1&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;medium&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;yulOptimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2020-2&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;privateCanBeOverridden&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Private methods can be overridden by inheriting contracts.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;While private methods of base contracts are not visible and cannot be called directly from the derived contract, it is still possible to declare a function of the same name and type and thus change the behaviour of the base contract&#39;s function.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.3.0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.17&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2020-1&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;YulOptimizerRedundantAssignmentBreakContinue0.5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The Yul optimizer can remove essential assignments to variables declared inside for loops when Yul&#39;s continue or break statement is used. You are unlikely to be affected if you do not use inline assembly with for loops and continue and break statements.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The Yul optimizer has a stage that removes assignments to variables that are overwritten again or are not used in all following control-flow branches. This logic incorrectly removes such assignments to variables declared inside a for loop if they can be removed in a control-flow branch that ends with ``break`` or ``continue`` even though they cannot be removed in other control-flow branches. Variables declared outside of the respective for loop are not affected.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.8&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.16&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;yulOptimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2019-10&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ABIEncoderV2LoopYulOptimizer&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;If both the experimental ABIEncoderV2 and the experimental Yul optimizer are activated, one component of the Yul optimizer may reuse data in memory that has been changed in the meantime.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The Yul optimizer incorrectly replaces ``mload`` and ``sload`` calls with values that have been previously written to the load location (and potentially changed in the meantime) if all of the following conditions are met: (1) there is a matching ``mstore`` or ``sstore`` call before; (2) the contents of memory or storage is only changed in a function that is called (directly or indirectly) in between the first store and the load call; (3) called function contains a for loop where the same memory location is changed in the condition or the post or body block. When used in Solidity mode, this can only happen if the experimental ABIEncoderV2 is activated and the experimental Yul optimizer has been activated manually in addition to the regular optimizer in the compiler settings.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.14&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.15&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;ABIEncoderV2&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">            </span><span class="s2">&quot;optimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">            </span><span class="s2">&quot;yulOptimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2019-9&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ABIEncoderV2CalldataStructsWithStaticallySizedAndDynamicallyEncodedMembers&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Reading from calldata structs that contain dynamically encoded, but statically-sized members can result in incorrect values.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;When a calldata struct contains a dynamically encoded, but statically-sized member, the offsets for all subsequent struct members are calculated incorrectly. All reads from such members will result in invalid values. Only calldata structs are affected, i.e. this occurs in external functions with such structs as argument. Using affected structs in storage or memory or as arguments to public functions on the other hand works correctly.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.6&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.11&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;ABIEncoderV2&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2019-8&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SignedArrayStorageCopy&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Assigning an array of signed integers to a storage array of different type can lead to data corruption in that array.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;In two&#39;s complement, negative integers have their higher order bits set. In order to fit into a shared storage slot, these have to be set to zero. When a conversion is done at the same time, the bits to set to zero were incorrectly determined from the source and not the target type. This means that such copy operations can lead to incorrect values being stored.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2019/06/25/solidity-storage-array-bugs/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.7&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.10&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low/medium&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2019-7&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ABIEncoderV2StorageArrayWithMultiSlotElement&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Storage arrays containing structs or other statically-sized arrays are not read properly when directly encoded in external function calls or in abi.encode*.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;When storage arrays whose elements occupy more than a single storage slot are directly encoded in external function calls or using abi.encode*, their elements are read in an overlapping manner, i.e. the element pointer is not properly advanced between reads. This is not a problem when the storage data is first copied to a memory variable or if the storage array only contains value types or dynamically-sized arrays.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2019/06/25/solidity-storage-array-bugs/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.16&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.10&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;ABIEncoderV2&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2019-6&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;DynamicConstructorArgumentsClippedABIV2&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;A contract&#39;s constructor that takes structs or arrays that contain dynamically-sized arrays reverts or decodes to invalid data.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;During construction of a contract, constructor parameters are copied from the code section to memory for decoding. The amount of bytes to copy was calculated incorrectly in case all parameters are statically-sized but contain dynamically-sized arrays as struct members or inner arrays. Such types are only available if ABIEncoderV2 is activated.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.16&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.9&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;ABIEncoderV2&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2019-5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;UninitializedFunctionPointerInConstructor&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Calling uninitialized internal function pointers created in the constructor does not always revert and can cause unexpected behaviour.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Uninitialized internal function pointers point to a special piece of code that causes a revert when called. Jump target positions are different during construction and after deployment, but the code for setting this special jump target only considered the situation after deployment.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.8&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2019-5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;UninitializedFunctionPointerInConstructor_0.4.x&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Calling uninitialized internal function pointers created in the constructor does not always revert and can cause unexpected behaviour.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Uninitialized internal function pointers point to a special piece of code that causes a revert when called. Jump target positions are different during construction and after deployment, but the code for setting this special jump target only considered the situation after deployment.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.26&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2019-4&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;IncorrectEventSignatureInLibraries&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Contract types used in events in libraries cause an incorrect event signature hash&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Instead of using the type `address` in the hashed signature, the actual contract name was used, leading to a wrong hash in the logs.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.8&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2019-4&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;IncorrectEventSignatureInLibraries_0.4.x&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Contract types used in events in libraries cause an incorrect event signature hash&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Instead of using the type `address` in the hashed signature, the actual contract name was used, leading to a wrong hash in the logs.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.3.0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.26&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2019-3&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ABIEncoderV2PackedStorage&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Storage structs and arrays with types shorter than 32 bytes can cause data corruption if encoded directly from storage using the experimental ABIEncoderV2.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Elements of structs and arrays that are shorter than 32 bytes are not properly decoded from storage when encoded directly (i.e. not via a memory type) using ABIEncoderV2. This can cause corruption in the values themselves but can also overwrite other parts of the encoded data.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2019/03/26/solidity-optimizer-and-abiencoderv2-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.7&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;ABIEncoderV2&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2019-3&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ABIEncoderV2PackedStorage_0.4.x&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Storage structs and arrays with types shorter than 32 bytes can cause data corruption if encoded directly from storage using the experimental ABIEncoderV2.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Elements of structs and arrays that are shorter than 32 bytes are not properly decoded from storage when encoded directly (i.e. not via a memory type) using ABIEncoderV2. This can cause corruption in the values themselves but can also overwrite other parts of the encoded data.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2019/03/26/solidity-optimizer-and-abiencoderv2-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.19&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.26&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;ABIEncoderV2&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2019-2&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;IncorrectByteInstructionOptimization&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The optimizer incorrectly handles byte opcodes whose second argument is 31 or a constant expression that evaluates to 31. This can result in unexpected values.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The optimizer incorrectly handles byte opcodes that use the constant 31 as second argument. This can happen when performing index access on bytesNN types with a compile-time constant value (not index) of 31 or when using the byte opcode in inline assembly.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2019/03/26/solidity-optimizer-and-abiencoderv2-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.7&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;optimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2019-1&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;DoubleShiftSizeOverflow&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Double bitwise shifts by large constants whose sum overflows 256 bits can result in unexpected values.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Nested logical shift operations whose total shift size is 2**256 or more are incorrectly optimized. This only applies to shifts by numbers of bits that are compile-time constant expressions.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2019/03/26/solidity-optimizer-and-abiencoderv2-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.5.6&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;optimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="w">            </span><span class="s2">&quot;evmVersion&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;&gt;=constantinople&quot;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2018-4&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ExpExponentCleanup&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Using the ** operator with an exponent of type shorter than 256 bits can result in unexpected values.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Higher order bits in the exponent are not properly cleaned before the EXP opcode is applied if the type of the exponent expression is smaller than 256 bits and not smaller than the type of the base. In that case, the result might be larger than expected if the exponent is assumed to lie within the value range of the type. Literal numbers as exponents are unaffected as are exponents or bases of type uint256.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2018/09/13/solidity-bugfix-release/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.25&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;medium/high&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;check&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="s2">&quot;regex-source&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;[^/]\\*\\* *[^/0-9 ]&quot;</span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2018-3&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;EventStructWrongData&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Using structs in events logged wrong data.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;If a struct is used in an event, the address of the struct is logged instead of the actual data.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2018/09/13/solidity-bugfix-release/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.17&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.25&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;check&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="s2">&quot;ast-compact-json-path&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;$..[?(@.nodeType === &#39;EventDefinition&#39;)]..[?(@.nodeType === &#39;UserDefinedTypeName&#39; &amp;&amp; @.typeDescriptions.typeString.startsWith(&#39;struct&#39;))]&quot;</span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2018-2&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;NestedArrayFunctionCallDecoder&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Calling functions that return multi-dimensional fixed-size arrays can result in memory corruption.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;If Solidity code calls a function that returns a multi-dimensional fixed-size array, array elements are incorrectly interpreted as memory pointers and thus can cause memory corruption if the return values are accessed. Calling functions with multi-dimensional fixed-size arrays is unaffected as is returning fixed-size arrays from function calls. The regular expression only checks if such functions are present, not if they are called, which is required for the contract to be affected.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2018/09/13/solidity-bugfix-release/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.1.4&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.22&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;medium&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;check&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="s2">&quot;regex-source&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;returns[^;{]*\\[\\s*[^\\] \\t\\r\\n\\v\\f][^\\]]*\\]\\s*\\[\\s*[^\\] \\t\\r\\n\\v\\f][^\\]]*\\][^{;]*[;{]&quot;</span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2018-1&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;OneOfTwoConstructorsSkipped&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;If a contract has both a new-style constructor (using the constructor keyword) and an old-style constructor (a function with the same name as the contract) at the same time, one of them will be ignored.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;If a contract has both a new-style constructor (using the constructor keyword) and an old-style constructor (a function with the same name as the contract) at the same time, one of them will be ignored. There will be a compiler warning about the old-style constructor, so contracts only using new-style constructors are fine.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.22&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.23&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2017-5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ZeroFunctionSelector&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;It is possible to craft the name of a function such that it is executed instead of the fallback function in very specific circumstances.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;If a function has a selector consisting only of zeros, is payable and part of a contract that does not have a fallback function and at most five external functions in total, this function is called instead of the fallback function if Ether is sent to the contract without data.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.18&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;very low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2017-4&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;DelegateCallReturnValue&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The low-level .delegatecall() does not return the execution outcome, but converts the value returned by the functioned called to a boolean instead.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The return value of the low-level .delegatecall() function is taken from a position in memory, where the call data or the return data resides. This value is interpreted as a boolean and put onto the stack. This means if the called function returns at least 32 zero bytes, .delegatecall() returns false even if the call was successful.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.3.0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.15&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2017-3&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ECRecoverMalformedInput&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The ecrecover() builtin can return garbage for malformed input.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The ecrecover precompile does not properly signal failure for malformed input (especially in the &#39;v&#39; argument) and thus the Solidity function can return data that was previously present in the return area in memory.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.14&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;medium&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2017-2&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SkipEmptyStringLiteral&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;If \&quot;\&quot; is used in a function call, the following function arguments will not be correctly passed to the function.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;If the empty string literal \&quot;\&quot; is used as an argument in a function call, it is skipped by the encoder. This has the effect that the encoding of all arguments following this is shifted left by 32 bytes and thus the function call data is corrupted.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.12&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2017-1&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ConstantOptimizerSubtraction&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;In some situations, the optimizer replaces certain numbers in the code with routines that compute different numbers.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The optimizer tries to represent any number in the bytecode by routines that compute them with less gas. For some special numbers, an incorrect routine is generated. This could allow an attacker to e.g. trick victims about a specific amount of ether, or function calls to call different functions (or none at all).&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2017/05/03/solidity-optimizer-bug/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.11&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;optimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2016-11&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;IdentityPrecompileReturnIgnored&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Failure of the identity precompile was ignored.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Calls to the identity contract, which is used for copying memory, ignored its return value. On the public chain, calls to the identity precompile can be made in a way that they never fail, but this might be different on private chains.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.7&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2016-10&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;OptimizerStateKnowledgeNotResetForJumpdest&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The optimizer did not properly reset its internal state at jump destinations, which could lead to data corruption.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The optimizer performs symbolic execution at certain stages. At jump destinations, multiple code paths join and thus it has to compute a common state from the incoming edges. Computing this common state was simplified to just use the empty state, but this implementation was not done properly. This bug can cause data corruption.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;medium&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.6&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;optimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2016-9&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;HighOrderByteCleanStorage&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;For short types, the high order bytes were not cleaned properly and could overwrite existing data.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Types shorter than 32 bytes are packed together into the same 32 byte storage slot, but storage writes always write 32 bytes. For some types, the higher order bytes were not cleaned properly, which made it sometimes possible to overwrite a variable in storage when writing to another one.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;link&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;https://blog.soliditylang.org/2016/11/01/security-alert-solidity-variables-can-overwritten-storage/&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;high&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.1.6&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.4&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2016-8&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;OptimizerStaleKnowledgeAboutSHA3&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The optimizer did not properly reset its knowledge about SHA3 operations resulting in some hashes (also used for storage variable positions) not being calculated correctly.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The optimizer performs symbolic execution in order to save re-evaluating expressions whose value is already known. This knowledge was not properly reset across control flow paths and thus the optimizer sometimes thought that the result of a SHA3 operation is already present on the stack. This could result in data corruption by accessing the wrong storage slot.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;medium&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.3&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;optimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2016-7&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;LibrariesNotCallableFromPayableFunctions&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Library functions threw an exception when called from a call that received Ether.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Library functions are protected against sending them Ether through a call. Since the DELEGATECALL opcode forwards the information about how much Ether was sent with a call, the library function incorrectly assumed that Ether was sent to the library and threw an exception.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;introduced&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.0&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.2&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2016-6&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SendFailsForZeroEther&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The send function did not provide enough gas to the recipient if no Ether was sent with it.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The recipient of an Ether transfer automatically receives a certain amount of gas from the EVM to handle the transfer. In the case of a zero-transfer, this gas is not provided which causes the recipient to throw an exception.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.4.0&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2016-5&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;DynamicAllocationInfiniteLoop&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Dynamic allocation of an empty memory array caused an infinite loop and thus an exception.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Memory arrays can be created provided a length. If this length is zero, code was generated that did not terminate and thus consumed all gas.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.3.6&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2016-4&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;OptimizerClearStateOnCodePathJoin&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The optimizer did not properly reset its internal state at jump destinations, which could lead to data corruption.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The optimizer performs symbolic execution at certain stages. At jump destinations, multiple code paths join and thus it has to compute a common state from the incoming edges. Computing this common state was not done correctly. This bug can cause data corruption, but it is probably quite hard to use for targeted attacks.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;low&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.3.6&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;conditions&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s2">&quot;optimizer&quot;</span><span class="o">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2016-3&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;CleanBytesHigherOrderBits&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The higher order bits of short bytesNN types were not cleaned before comparison.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Two variables of type bytesNN were considered different if their higher order bits, which are not part of the actual value, were different. An attacker might use this to reach seemingly unreachable code paths by providing incorrectly formatted input data.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;medium/high&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.3.3&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2016-2&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;ArrayAccessCleanHigherOrderBits&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Access to array elements for arrays of types with less than 32 bytes did not correctly clean the higher order bits, causing corruption in other array elements.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Multiple elements of an array of values that are shorter than 17 bytes are packed into the same storage slot. Writing to a single element of such an array did not properly clean the higher order bytes and thus could lead to data corruption.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;medium/high&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.3.1&quot;</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="s2">&quot;uid&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;SOL-2016-1&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;name&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;AncientCompiler&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;summary&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;This compiler version is ancient and might contain several undocumented or undiscovered bugs.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;description&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;The list of bugs is only kept for compiler versions starting from 0.3.0, so older versions might contain undocumented bugs.&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;severity&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;high&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;fixed&quot;</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;0.3.0&quot;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">]</span>
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="security-considerations.html" class="btn btn-neutral float-left" title="Security Considerations" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="050-breaking-changes.html" class="btn btn-neutral float-right" title="Solidity v0.5.0 Breaking Changes" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2023, The Solidity Authors.
      <span class="commit">Revision <code>f704f362</code>.
      </span></p>
  </div>

  
    <p>
        <a href="credits-and-attribution.html">Credits and attribution</a>.
    </p>


</footer>
        </div>
      </div>
    </section>
  </div>
  
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book fa-element"> RTD </span>

    <span class="fa fa-element">
    <input class="container_toggle" type="checkbox" id="switch" name="mode">
    <label for="switch"></label>
    </span>

    <span class="fa fa-v fa-element"> v: v0.8.23 <span class="fa fa-caret-down"></span></span>

    </span>
    <div class="rst-other-versions">
        <dl>
            <dt>Downloads</dt> 
            <dd><a href="http://docs.soliditylang.org/_/downloads/en/v0.8.23/pdf/">pdf</a></dd>
            
            <dd><a href="http://docs.soliditylang.org/_/downloads/en/v0.8.23/epub/">epub</a></dd>
            
        </dl>
        <dl>
            <dt>Versions</dt> 
            <dd><a href="https://docs.soliditylang.org/en/latest/">latest</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/stable/">stable</a></dd>
            
            <dd><a href="index.html">v0.8.23</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.8.22/">v0.8.22</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.8.21/">v0.8.21</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.8.20/">v0.8.20</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.8.19/">v0.8.19</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.8.18/">v0.8.18</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.8.17/">v0.8.17</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.8.16/">v0.8.16</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.8.15/">v0.8.15</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.8.14/">v0.8.14</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.8.13/">v0.8.13</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.8.12/">v0.8.12</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.8.11/">v0.8.11</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.8.10/">v0.8.10</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.8.9/">v0.8.9</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.8.8/">v0.8.8</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.8.7/">v0.8.7</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.8.6/">v0.8.6</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.8.5/">v0.8.5</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.8.4/">v0.8.4</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.8.3/">v0.8.3</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.8.2/">v0.8.2</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.8.1/">v0.8.1</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.8.0/">v0.8.0</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.7.6/">v0.7.6</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.7.5/">v0.7.5</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.7.4/">v0.7.4</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.7.3/">v0.7.3</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.7.2/">v0.7.2</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.7.1/">v0.7.1</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.7.0/">v0.7.0</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.6.12/">v0.6.12</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.6.11/">v0.6.11</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.6.10/">v0.6.10</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.6.9/">v0.6.9</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.6.8/">v0.6.8</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.6.7/">v0.6.7</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.6.6/">v0.6.6</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.6.5/">v0.6.5</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.6.4/">v0.6.4</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.6.3/">v0.6.3</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.6.2/">v0.6.2</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.6.1/">v0.6.1</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.6.0/">v0.6.0</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.5.17/">v0.5.17</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.5.16/">v0.5.16</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.5.15/">v0.5.15</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.5.14/">v0.5.14</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.5.13/">v0.5.13</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.5.12/">v0.5.12</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.5.11/">v0.5.11</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.5.10/">v0.5.10</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.5.9/">v0.5.9</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.5.8/">v0.5.8</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.5.7/">v0.5.7</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.5.6/">v0.5.6</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.5.5/">v0.5.5</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.5.4/">v0.5.4</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.5.3/">v0.5.3</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.5.2/">v0.5.2</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.5.1/">v0.5.1</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.5.0/">v0.5.0</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.4.26/">v0.4.26</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.4.25/">v0.4.25</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.4.24/">v0.4.24</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.4.23/">v0.4.23</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.4.22/">v0.4.22</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.4.21/">v0.4.21</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.4.20/">v0.4.20</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.4.19/">v0.4.19</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.4.18/">v0.4.18</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.4.17/">v0.4.17</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.4.16/">v0.4.16</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.4.15/">v0.4.15</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.4.14/">v0.4.14</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.4.13/">v0.4.13</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.4.12/">v0.4.12</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.4.11/">v0.4.11</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.4.10/">v0.4.10</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.4.9/">v0.4.9</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.4.8/">v0.4.8</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.4.7/">v0.4.7</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.4.6/">v0.4.6</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.4.5/">v0.4.5</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.4.4/">v0.4.4</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.4.3/">v0.4.3</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.4.2/">v0.4.2</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.4.1/">v0.4.1</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.4.0/">v0.4.0</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.3.6/">v0.3.6</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.3.5/">v0.3.5</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.3.4/">v0.3.4</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.3.3/">v0.3.3</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.3.2/">v0.3.2</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.3.1/">v0.3.1</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.3.0/">v0.3.0</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.2.2/">v0.2.2</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.2.1/">v0.2.1</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.2.0/">v0.2.0</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.1.7/">v0.1.7</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.1.6/">v0.1.6</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.1.5/">v0.1.5</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.1.4/">v0.1.4</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.1.3/">v0.1.3</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/v0.1.2/">v0.1.2</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/develop/">develop</a></dd>
            
            <dd><a href="https://docs.soliditylang.org/en/breaking/">breaking</a></dd>
            
        </dl>
        <dl>
            
            <dt>On Read the Docs</dt>
            <dd>
                <a href="http://readthedocs.org/projects/solidity/?fromdocs=solidity">Project Home</a>
            </dd>
            <dd>
                <a href="http://readthedocs.org/builds/solidity/?fromdocs=solidity">Builds</a>
            </dd>
        </dl>
    </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>

<!-- Mirrored from docs.soliditylang.org/en/v0.8.23/bugs.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 02 Jan 2024 20:36:17 GMT -->
</html>